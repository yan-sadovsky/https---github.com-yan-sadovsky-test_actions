'use strict';

var Status;
(function (Status) {
    Status["FAILED"] = "failed";
    Status["BROKEN"] = "broken";
    Status["PASSED"] = "passed";
    Status["SKIPPED"] = "skipped";
})(Status || (Status = {}));
var Stage;
(function (Stage) {
    Stage["SCHEDULED"] = "scheduled";
    Stage["RUNNING"] = "running";
    Stage["FINISHED"] = "finished";
    Stage["PENDING"] = "pending";
    Stage["INTERRUPTED"] = "interrupted";
})(Stage || (Stage = {}));
var LabelName;
(function (LabelName) {
    LabelName["ALLURE_ID"] = "ALLURE_ID";
    LabelName["AS_ID"] = "ALLURE_ID";
    LabelName["SUITE"] = "suite";
    LabelName["PARENT_SUITE"] = "parentSuite";
    LabelName["SUB_SUITE"] = "subSuite";
    LabelName["EPIC"] = "epic";
    LabelName["FEATURE"] = "feature";
    LabelName["STORY"] = "story";
    LabelName["SEVERITY"] = "severity";
    LabelName["TAG"] = "tag";
    LabelName["OWNER"] = "owner";
    LabelName["LEAD"] = "lead";
    LabelName["HOST"] = "host";
    LabelName["THREAD"] = "thread";
    LabelName["TEST_METHOD"] = "testMethod";
    LabelName["TEST_CLASS"] = "testClass";
    LabelName["PACKAGE"] = "package";
    LabelName["FRAMEWORK"] = "framework";
    LabelName["LANGUAGE"] = "language";
    LabelName["LAYER"] = "layer";
})(LabelName || (LabelName = {}));
var Severity;
(function (Severity) {
    Severity["BLOCKER"] = "blocker";
    Severity["CRITICAL"] = "critical";
    Severity["NORMAL"] = "normal";
    Severity["MINOR"] = "minor";
    Severity["TRIVIAL"] = "trivial";
})(Severity || (Severity = {}));
var ContentType;
(function (ContentType) {
    ContentType["TEXT"] = "text/plain";
    ContentType["XML"] = "application/xml";
    ContentType["HTML"] = "text/html";
    ContentType["CSV"] = "text/csv";
    ContentType["TSV"] = "text/tab-separated-values";
    ContentType["CSS"] = "text/css";
    ContentType["URI"] = "text/uri-list";
    ContentType["SVG"] = "image/svg+xml";
    ContentType["PNG"] = "image/png";
    ContentType["JSON"] = "application/json";
    ContentType["ZIP"] = "application/zip";
    ContentType["WEBM"] = "video/webm";
    ContentType["JPEG"] = "image/jpeg";
    ContentType["MP4"] = "video/mp4";
})(ContentType || (ContentType = {}));
var LinkType;
(function (LinkType) {
    LinkType["ISSUE"] = "issue";
    LinkType["TMS"] = "tms";
})(LinkType || (LinkType = {}));

var stripAnsi$1 = {exports: {}};

var ansiRegex$1 = options => {
	options = Object.assign({
		onlyFirst: false
	}, options);

	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, options.onlyFirst ? undefined : 'g');
};

const ansiRegex = ansiRegex$1;

const stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

stripAnsi$1.exports = stripAnsi;
stripAnsi$1.exports.default = stripAnsi;

var MessageType;
(function (MessageType) {
    MessageType["TEST_STARTED"] = "TEST_STARTED";
    MessageType["TEST_ENDED"] = "TEST_ENDED";
    MessageType["STEP_STARTED"] = "STEP_STARTED";
    MessageType["STEP_ENDED"] = "STEP_ENDED";
    MessageType["METADATA"] = "METADATA";
    MessageType["SCREENSHOT"] = "SCREENSHOT";
})(MessageType || (MessageType = {}));

const createFinalMesage = () => ({
    startMessage: undefined,
    endMessage: undefined,
    messages: [],
});
const { EVENT_TEST_BEGIN, EVENT_TEST_FAIL, EVENT_TEST_PASS } = Mocha.Runner.constants;
const getSuitePath = (test) => {
    const path = [];
    let currentSuite = test.parent;
    while (currentSuite) {
        if (currentSuite.title) {
            path.unshift(currentSuite.title);
        }
        currentSuite = currentSuite.parent;
    }
    return path;
};
const getStepsMessagesPair = (reportMessage) => reportMessage.messages.reduce((acc, message) => {
    if (message.type !== MessageType.STEP_STARTED && message.type !== MessageType.STEP_ENDED) {
        return acc;
    }
    if (message.type === MessageType.STEP_STARTED) {
        acc.push([message]);
        return acc;
    }
    const unfinishedStepIdx = acc.findLastIndex((step) => step.length === 1);
    if (unfinishedStepIdx === -1) {
        return acc;
    }
    acc[unfinishedStepIdx].push(message);
    return acc;
}, []);
Cypress.mocha
    .getRunner()
    .on(EVENT_TEST_BEGIN, (test) => {
    const reportMessage = createFinalMesage();
    reportMessage.startMessage = {
        specPath: getSuitePath(test).concat(test.title),
        filename: Cypress.spec.relative,
        start: Date.now(),
    };
    Cypress.env("allure", { reportMessage });
})
    .on(EVENT_TEST_PASS, () => {
    const reportMessage = Cypress.env("allure").reportMessage;
    const grouppedStepsMessage = getStepsMessagesPair(reportMessage);
    const unfinishedStepsMessages = grouppedStepsMessage.filter((step) => step.length === 1);
    unfinishedStepsMessages.forEach(() => {
        reportMessage.messages.push({
            type: MessageType.STEP_ENDED,
            payload: {
                stage: Stage.FINISHED,
                status: Status.PASSED,
                stop: Date.now(),
            },
        });
    });
    reportMessage.endMessage = {
        stage: Stage.FINISHED,
        status: Status.PASSED,
        stop: Date.now(),
    };
    Cypress.env("allure", { reportMessage });
})
    .on(EVENT_TEST_FAIL, (test, err) => {
    const reportMessage = Cypress.env("allure").reportMessage;
    reportMessage.endMessage = {
        stage: Stage.FINISHED,
        status: err.constructor.name === "AssertionError" ? Status.FAILED : Status.BROKEN,
        statusDetails: {
            message: err.message,
            trace: err.stack,
        },
        stop: Date.now(),
    };
    Cypress.env("allure", { reportMessage });
});
Cypress.Screenshot.defaults({
    onAfterScreenshot: (_, details) => {
        const reportMessage = Cypress.env("allure").reportMessage;
        reportMessage.messages.push({
            type: MessageType.SCREENSHOT,
            payload: {
                path: details.path,
                name: details.name || "Screenshot",
            },
        });
        Cypress.env("allure", { reportMessage });
    },
});
Cypress.on("fail", (err) => {
    const reportMessage = Cypress.env("allure").reportMessage;
    const hasSteps = reportMessage.messages.some((message) => message.type === MessageType.STEP_STARTED);
    if (!hasSteps) {
        throw err;
    }
    const grouppedStepsMessage = getStepsMessagesPair(reportMessage);
    const unfinishedStepsMessages = grouppedStepsMessage.filter((step) => step.length === 1);
    if (unfinishedStepsMessages.length === 0) {
        throw err;
    }
    const failedStepsStatus = err.constructor.name === "AssertionError" ? Status.FAILED : Status.BROKEN;
    unfinishedStepsMessages.forEach(() => {
        reportMessage.messages.push({
            type: MessageType.STEP_ENDED,
            payload: {
                stage: Stage.FINISHED,
                status: failedStepsStatus,
                stop: Date.now(),
                statusDetails: {
                    message: err.message,
                    trace: err.stack,
                },
            },
        });
    });
    Cypress.env("allure", { reportMessage });
    throw err;
});
afterEach(() => {
    const reportMessage = Cypress.env("allure").reportMessage;
    cy.task("allureReportTest", reportMessage, { log: false });
});
//# sourceMappingURL=commands.cjs.map
